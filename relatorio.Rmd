---
title: "Análise de Questionários do Projeto 'Meninas na Computação'"
output:
  html_notebook: 
    code_folding: hide
  html_document: default
---
```{r, include=FALSE}
rm(list = ls())
options("scipen"=100, "digits"=2)

library(readxl)
library(readr)
library(arules)
library(ggplot2)
library(reshape2)
library(gridExtra)
library(stringr)
library(knitr)
library(arules)
```

Este estudo é uma análise estatística sobre o projeto [Meninas na Computação](http://meninas.cic.unb.br/), coordenado pela professora Dra. Maristela Terto e Holanda et al. 

```{r}
respostas <- read_excel("../dados/raw.xlsx", sheet = "unificado", na = "")

respostas$Q1 <- NULL
respostas$Q2 <- NULL
respostas$Serie <- stringr::str_trim(respostas$Serie, side = "both")
respostas <- as.data.frame(lapply(respostas, as.factor))
respostas <- respostas[, c(1, 5, 2, 3, 4, 6:ncol(respostas))]
```

Durante os anos de 2011 a 2014, foram entrevistados `r nrow(respostas)` alunos do nível fundamental, médio e superior, sobre o curso superior que pretendiam seguir. 

O questionário possui 14 questões que foram desmembradas em 36 variáveis.

O primeiro passo do estudo foi recuperar as respostas dos questionários. 

O segundo passo envolveu a preparação dos dados. Em primeiro lugar, os questionários foram unificados em uma única tabela, a fim de facilitar a manipulação.

Como o estudo consiste em identificar as motivações das alunas entrevistadas em seguir ou não uma carreira em Ciência da Computação, foram retirados os `r nrow(respostas[respostas$Sexo == 'M',])` entrevistados de sexo masculino.

```{r}
respostas <- subset(respostas, respostas$Sexo == "F")
respostas$Sexo <- NULL
```

São encontradas as seguintes distribuições de série na amostra:

```{r}
series <- aggregate(x = list(Quantidade = respostas$Serie), by = list(Ano = respostas$Ano, Serie = respostas$Serie), FUN=length)

por_ano <- aggregate(x = list(Total = respostas$Serie), by = list(Ano = respostas$Ano), FUN=length)

series <- merge(series, por_ano)

series$Percentual <- series$Quantidade * 100 / series$Total

p = ggplot(data = series, aes(x = "", y = Percentual, fill = Serie))  
p = p + geom_bar(width = 1, stat = "identity")
p = p + facet_grid(facets = . ~ Ano)
p = p + coord_polar(theta = "y", start = 0) 
p = p + scale_x_discrete()
p = p + xlab("") + ylab("") + labs(fill="Ano") 
p = p + ggtitle("Percentual de Entrevistadas por Série em cada Ano")
p
```

As alunas responderam da seguinte forma sobre a área que gostariam de cursar:

```{r}
cursos <- aggregate(x = list(Quantidade = respostas$Fara_Curso_Superior), by = list(Ano = respostas$Ano, Fara_Curso_Superior = respostas$Fara_Curso_Superior), FUN=length)

por_ano <- aggregate(x = list(Total = respostas$Fara_Curso_Superior), by = list(Ano = respostas$Ano), FUN=length)

cursos <- merge(cursos, por_ano)

cursos$Percentual <- cursos$Quantidade * 100 / cursos$Total

p = ggplot(data = cursos, aes(x = "", y = Percentual, fill = Fara_Curso_Superior))  
p = p + geom_bar(width = 1, stat = "identity")
p = p + facet_grid(facets = . ~ Ano)
p = p + coord_polar(theta = "y", start = 0) 
p = p + scale_x_discrete()
p = p + xlab("") + ylab("") + labs(fill="Ano") 
p = p + ggtitle("Percentual de Entrevistadas por Área de Interesse")
p
```

Podemos observar que os percentuais permanecem ao longo dos anos, sendo a preferência por Ciências Biológicas e de Saúde em torno de `r round(cursos$Percentual[cursos$Ano == 2011 & cursos$Fara_Curso_Superior == 'Biologicas e Saude'])`\%, para Humanas cerca de `r round(cursos$Percentual[cursos$Ano == 2011 & cursos$Fara_Curso_Superior == 'Humanas'])`\% e para Exatas próximo a `r round(cursos$Percentual[cursos$Ano == 2011 & cursos$Fara_Curso_Superior == 'Exatas'])`\%.

A opinião das alunas sobre o cursar Ciência da Computação é representada nos gráficos a seguir:

```{r}
comp <- aggregate(x = list(Quantidade = respostas$Fara_Computacao), by = list(Ano = respostas$Ano, Fara_Computacao = respostas$Fara_Computacao), FUN=length)

por_ano <- aggregate(x = list(Total = respostas$Fara_Computacao), by = list(Ano = respostas$Ano), FUN=length)

comp <- merge(comp, por_ano)

comp$Percentual <- comp$Quantidade * 100 / comp$Total

p = ggplot(data = comp, aes(x = "", y = Percentual, fill = Fara_Computacao))  
p = p + geom_bar(width = 1, stat = "identity")
p = p + facet_grid(facets = . ~ Ano)
p = p + coord_polar(theta = "y", start = 0) 
p = p + scale_x_discrete()
p = p + xlab("") + ylab("") + labs(fill="Ano") 
p = p + ggtitle("Percentual de Entrevistadas por Interesse em Computação")
p
```

Será realizada a seguir uma análise de variância, no intuito de identificar, pergunta a pergunta, se as quantidades médias das respostas são estatisticamente diferentes ou se a diferença identificada nas médias trata-se de ruído. 

A análise de variância não será completa sem um teste de comparação de médias: após identificar diferenças reais entre as respostas, será efetuado o teste de Tukey que dirá quais dos itens são diferentes entre si.

Para que seja feita a análise de variância, a amostra deve atender certas pressuposições básicas:
1) os erros são variáveis aleatórias independentes;
2) a variância é constante;
3) a distribuição dos erros é normal ou aproximadamente normal.


Como exemplo, será efetuada isoladamente a análise de variância do atributo **Fara_Computacao** em relação ao atributo **Ano**, com as respostas *Sim*, *Nao* e *Nao sei ainda* como blocos de estudo e os anos como o tratamentos. A variável observada é o percentual de respostas atribuídas em cada item, avaliada a cada ano.

A utilização do percentual de respostas a cada item previne que a diferença na quantidade de entrevistas prejudique a análise. 

```{r}
Fara_Computacao <- aggregate(x = list(Quantidade = respostas$Ano), by = list(Ano = respostas$Ano, Tratamento = respostas$Fara_Computacao), FUN=length)

Total <- aggregate(x = list(Total = respostas$Fara_Computacao), by = list(Ano = respostas$Ano), FUN=length)

Fara_Computacao <- merge(Fara_Computacao, Total)

Fara_Computacao$Percentual <- Fara_Computacao$Quantidade / Fara_Computacao$Total

knit_print(Fara_Computacao)

knit_print(M <- aggregate(x = list(Media = Fara_Computacao$Percentual), by = list(Tratamento = Fara_Computacao$Tratamento), FUN=mean))
cat("\n")

fit <- aov(Percentual ~ Tratamento, data = Fara_Computacao)
knit_print(anova(fit))
knit_print(TukeyHSD(fit, 'Tratamento'))
par(mfrow=c(2,2))
plot(fit)
```

A partir do p-valor do tratamento **Ano** (Pr(>F)) abaixo de 5%, há evidências de uma diferença na quantidade de alunas que optam por computação devido à passagem do tempo.

Ao efetuar o teste de Tukey, identificamos que, enquanto as médias das respostas *Nao* e *Nao sei ainda* diferem estatisticamente, com os valores `r 100 * M$Media[M$Tratamento == "Nao"]`\% e `r 100 * M$Media[M$Tratamento == "Nao sei ainda"]`\%, não se identifica diferença entre a resposta *Sim* e as outras. Disso, pode-se concluir que quando o respondente informa *Sim*, não há garantia que o percentual `r 100 * M$Media[M$Tratamento == "Sim"]`\% seja realmente maior que o da resposta *Nao* e menor que o da resposta *Nao sei ainda*.

Em outras palavras, pode-se dizer que o percentual de pessoas que  responderam *Nao* é decididamente menor que o percentual das que responderam *Nao sei ainda*.

<!--
```{r}
tam_amostra <- 400
niveis <- levels(respostas$Ano)
amostra_anova <- NULL
set.seed(2017)
for (i in 1:length(niveis)) {
 temp <- respostas[respostas$Ano == niveis[i],]
 rownames(temp) <- 1:nrow(temp)
 temp <- temp[sample(nrow(temp), tam_amostra), ]
 if (is.null(amostra_anova)) {
   amostra_anova <- temp
 } else {
   amostra_anova <- rbind(amostra_anova, temp)
 }
}
rm("temp")
```
-->

A seguir serão apresentadas as análises de variância dos atributos coletados nas entrevistas.

```{r}
par(mfrow=c(2,2))
for (i in 3:ncol(respostas)) {
  temp <- aggregate(list(Quantidade = respostas[, i]), by = list(Ano = respostas$Ano, Tratamento = respostas[, i]), FUN=length)

  # complementar temp com dominios zerados
  temp2 <- expand.grid(Tratamento = levels(respostas[, i]), Ano = levels(respostas$Ano))
  temp <- merge(temp, temp2, all.y = TRUE)
  temp$Quantidade[is.na(temp$Quantidade)] <- 0
  
  Total <- aggregate(x = list(Total = respostas[, i]), by = list(Ano = respostas$Ano), FUN=length)

  temp <- merge(temp, Total)

  temp$Percentual <- temp$Quantidade / temp$Total
  
  nome <- colnames(respostas)[i]
  cat(paste("\nTratamento:", nome, "\n"))  
  cat("\n")
  knit_print(temp)
  cat("\n")
  
  knit_print(aggregate(x = list(Media = temp$Percentual), by = list(Tratamento = temp$Tratamento), FUN=mean))
  cat("\n")
  
  fit <- aov(Percentual ~ Tratamento, data = temp)
  knit_print(anova(fit))
  
  knit_print(TukeyHSD(fit, 'Tratamento'))
  
  plot(fit)
  
  assign(nome, temp)
}

```


O próximo passo é identificar se há combinações de atributos que expliquem essa opção. Para isso será utilizado o algoritmo Apriori de mineração de regras de associação.

```{r}
# regras = apriori(data = respostas)
# regras = apriori(data = respostas, parameter = list(minlen=2, supp=0.1, conf=0.8, maxtime=300), appearance = list(rhs = c("Fara_Computacao=Sim", "Fara_Computacao=Nao", "Fara_Computacao=Nao sei ainda"), default="lhs"))

# regras.ordem <- sort(regras, by="lift")
# write(regras.ordem, file="../dados/regras.txt")
```

